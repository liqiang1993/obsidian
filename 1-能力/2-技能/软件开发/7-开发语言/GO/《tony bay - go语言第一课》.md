# 开篇词

## 学习go的三个理由

### 对初学者足够友善，能够快速上手

### 生产力与性能的结合

### 快乐又有钱景

## 怎样学才能少走弯路

### 三个诀窍

#### 心定

#### 手勤

#### 脑勤

### 五个阶段

#### 前置篇，心定建立认同感

#### 入门篇，手勤多动手实践

#### 基础篇，脑勤多理解，扎实基础

#### 核心篇，脑勤➕建立自己的go应用设计意识

#### 实战篇，攻克go开发的最后一公里

# 前置篇：心定之旅

## 前世今生：你不得不了解的go的历史和现状

### go语言是怎样诞生的

#### 痛点：当时谷歌内部的主力语言是c++，但是c++的巨大复杂性，编译构建速度慢以及在编写服务端程序时对并发支持的不足

#### 构建go的主要思路：在c语言的基础上修正一些明显的缺陷，删除一些被诟病较多的特性，增加一些缺失的功能

#### 创始人

##### Ken Thompson

##### Rob Pike

##### Robert Griesemer

#### 承诺：只要符合 Go 1 语言规范的源代码，Go 编译器将保证向后兼容（backwards compatible），也就是说我们使用新版编译器也可以正确编译用老版本语法编写的代码。

### go是否值得学习

#### go语言学习的最佳时刻已经到来；

## 拒绝入门到放弃，go语言的设计哲学是怎么一回事

### 简单

### 显示

### 组合

### 并发

### 面向工程

# 入门篇：勤加练手

## 配好环境：选择一种最适合自己的go安装方法

### 选择go版本

#### 版本发布策略：一般是在二月份和八月份发布。Go 团队承诺对最新的两个 Go 稳定大版本提供支持

### 安装go

#### 在Linux上安装

#### 在mac上安装

#### 在Windows 上安装

#### 安装多个go版本

##### 重新设置path 环境变量

##### go get 命令

-   这种方法有一个前提，那就是当前系统中已经通过标准方法安装过某个版本的 Go 了。
    

##### go get 命令安装非稳定版本

### 配置go

#### 子主题

##  ![](https://docimg7.docs.qq.com/image/xrl2tie8xrJhIVx-yRuTaw.png?w=960&h=1064)初窥门径：一个go程序的结构是怎样的

### Go 包是 Go 语言的基本组成单元。一个 Go 程序就是一组包的集合，所有 Go 代码都位于包中；

### Go 源码可以导入其他 Go 包，并使用其中的导出语法元素，包括类型、变量、函数、方法等，而且，main 函数是整个 Go 应用的入口函数；

### Go 源码需要先编译，再分发和运行。如果是单 Go 源文件的情况，我们可以直接使用 go build 命令 +Go 源文件名的方式编译。不过，对于复杂的 Go 项目，我们需要在 Go Module 的帮助下完成项目的构建。

## 标准先行：go项目的布局标准是怎样的

### 首先我们先来看 Go 可执行程序项目的典型结构布局

#### 子主题

###  ![](https://docimg3.docs.qq.com/image/gQW7MIPlisQmtzjo2IYUWg.png?w=704&h=852)典型项目结构分为五部分

#### 放在项目顶层的 Go Module 相关文件，包括 go.mod 和 go.sum；

#### cmd 目录：存放项目要编译构建的可执行文件所对应的 main 包的源码文件；

#### 项目包目录：每个项目下的非 main 包都“平铺”在项目的根目录下，每个目录对应一个 Go 包；

#### internal 目录：存放仅项目内部引用的 Go 包，这些包无法被项目之外引用；

#### vendor 目录：这是一个可选目录，为了兼容 Go 1.5 引入的 vendor 构建模式而存在的。这个目录下的内容均由 Go 命令自动维护，不需要开发者手工干预。

## 构建模式：go怎样解决包依赖管理的问题

### Go 构建模式是怎么演化的？

#### gopath

#### vendor

#### go module

### 深入 Go Module 构建模式

#### Go Module 的语义导入版本机制

##### 版本号前缀

##### 子主题

-   版本之间不相互兼容
    

##### 次版本号

##### 补丁版本号

#### Go Module 的最小版本选择原则

### Go 各版本构建模式机制和切换

#### 子主题

##  ![](https://docimg9.docs.qq.com/image/yY2KCjWoVlsG6JY4SbNWEg.png?w=2352&h=962)构建模式：go module 的6类常规操作

### 为当前 module 添加一个依赖

#### go get 命令将我们新增的依赖包下载到了本地 module 缓存里，并在 go.mod 文件的 require 段中新增了一行内容

#### go mod tidy

### 升级 / 降级依赖的版本

#### 那么我们可以在项目的 module 根目录下，执行带有版本号的 go get 命令

#### go mod edit + go mod tidy

### 添加一个主版本号大于 1 的依赖

#### 如果新旧版本的包使用相同的导入路径，那么新包与旧包是兼容的。也就是说，如果新旧两个包不兼容，那么我们就应该采用不同的导入路径

#### 在声明它的导入路径的基础上，加上版本号信息

### 升级依赖版本到一个不兼容版本

### 移除一个依赖

#### 从源码中删除对依赖项的导入语句

#### 我们还得用 go mod tidy 命令，将这个依赖项彻底从 Go Module 构建上下文中清除掉。go mod tidy 会自动分析源码依赖，而且将不再使用的依赖从 go.mod 和 go.sum 中移除

### 特殊情况：使用 vendor

#### 特别是在一些不方便访问外部网络，并且对 Go 应用构建性能敏感的环境，比如在一些内部的持续集成或持续交付环境（CI/CD）中，使用 vendor 机制可以实现与 Go Module 等价的构建。

## 入口函数和包初始化：搞清go程序的初始化次序

### main.main 函数：Go 应用的入口函数

### init 函数：Go 包的初始化函数

#### 每个 init 函数在整个 Go 程序生命周期内仅会被执行一次；

#### init 函数是顺序执行的，只有当一个 init 函数执行完毕后，才会去执行下一个 init 函数。

### Go 包的初始化次序

#### 常量、变量、init、main

#### 深度优先

#### 包内的init函数按照出现次序进行自动调用

### init 函数的用途

#### 这里我们先来看 init 函数的第一个常用用途：重置包级变量值。

#### init 函数的第二个常用用途，是实现对包级变量的复杂初始化。

#### 说完了这个，我们现在来讲 init 函数的第三个常用用途：在 init 函数中实现“注册模式”。

##### 实际上，这种通过在 init 函数中注册自己的实现的模式，就有效降低了 Go 包对外的直接暴露，尤其是包级变量的暴露，从而避免了外部通过包级变量对包状态的改动。

## 即学即练：构建一个web服务就是这么简单

# 基础篇：脑勤多理解

## 变量声明：静态语言有别于动态语言的重要特征

### 子主题

#### 1. 省略类型信息的声明：

#### 2. 短变量声明：

##### 只能在函数体内使用

### 包级变量的声明形式

#### 第一类：声明并同时显式初始化。

#### 第二类：声明但延迟初始化。

#### 这里还有一个注意事项，就是声明聚类与就近原则。

### 局部变量的声明形式

#### 第一类：对于延迟初始化的局部变量声明，我们采用通用的变量声明形式

#### 第二类：对于声明且显式初始化的局部变量，建议使用短变量声明形式

##### 这里我们还要注意：尽量在分支控制时使用短变量声明形式。

###   

##  ![](https://docimg1.docs.qq.com/image/WpeonX2A7O_mGB7lORkEnQ.png?w=2360&h=1216)代码块与作用域：如何保证变量不会被遮蔽？

### 代码块

#### 显式代码块

#### 隐式代码块

### 作用域

#### 原则就是声明于外层代码块中的标识符，其作用域包括所有内层代码块

## 基本数据类型：Go原生支持的数值类型有哪些？

### 整形

#### 整形溢出

#### 补码计算

##### 原码取反加一

### 浮点型

#### 符号位

#### 阶码

#### 尾数

### 复数型

## 基本数据类型：为什么Go要原生支持字符串类型？

### 原生支持字符串有什么好处？

#### 第一点：string 类型的数据是不可变的，提高了字符串的并发安全性和存储利用率

#### 第二点：没有结尾’\0’，而且获取长度的时间复杂度是常数时间，消除了获取字符串长度的开销。

#### 第三点：原生支持“所见即所得”的原始字符串，大大降低构造多行字符串时的心智负担。

#### 第四点：对非 ASCII 字符提供原生支持，消除了源码在不同环境下显示乱码的可能。

### Go 字符串的组成

#### 字节视角与字符视角

#### Unicode 码点

#### 一个 rune 实例就是一个 Unicode 字符，一个 Go 字符串也可以被视为 rune 实例的集合。我们可以通过字符字面值来初始化一个 rune 变量。

##### 由于表示码点的 rune 本质上就是一个整型数，所以我们还可用整型值来直接作为字符字面值给 rune 变量赋值

#### 字符字面值的表示方法

##### 通过单引号括起的字符字面值

##### Unicode 专用的转义字符\u 或\U 作为前缀

-   我们要注意，\u 后面接两个十六进制数。如果是用两个十六进制数无法表示的 Unicode 字符，我们可以使用\U，\U 后面可以接四个十六进制数来表示一个 Unicode 字符。
    

#### 字符串字面值

#### UTF-8 编码方案

#### Go 字符串类型的内部表示

##### string 类型其实是一个“描述符”，它本身并不真正存储字符串数据，而仅是由一个指向底层存储的指针和字符串的长度字段组成的

##### 我们直接将 string 类型通过函数 / 方法参数传入也不会带来太多的开销。因为传入的仅仅是一个“描述符”，而不是真正的字符串数据。

#### Go 字符串类型的常见操作

##### 下标操作

-   针对字节的操作
    

##### 字符迭代

-   for len
    

-   针对字节
    

-   for range
    

-   针对字符
    

##### 字符串连接

-   +/+=
    
-   strings.Builder
    
-   strings.Join
    
-   fmt.Sprintf
    

##### 字符串比较

##### 字符串转换

-   string是不可变的，运行时要为转换后的类型分配内存
    

## 常量：Go在“常量”设计上的创新有哪些？

### Go 语言的常量是一种在源码编译期间被创建的语法元素

### Go 常量的类型只局限于前面我们学过的 Go 基本数据类型，包括数值类型、字符串类型，以及只有两个取值（true 和 false）的布尔类型。

### Go 语言在常量方面的创新包括下面这几点

#### 支持无类型常量；

#### 支持隐式自动转型；

#### 可用于实现枚举。

##### Go 语言其实并没有原生提供枚举类型

##### Go 的 const 语法提供了“隐式重复前一个非空表达式”的机制

##### iota 是 Go 语言的一个预定义标识符，它表示的是 const 声明块（包括单行声明）中，每个常量所处位置在块中的偏移值（从零开始）

## 同构复合类型：从定长数组到变长切片

### Go 的数组类型包含两个重要属性：元素的类型和数组长度（元素的个数）

### Go 提供了预定义函数 len 可以用于获取一个数组类型变量的长度，通过 unsafe 包提供的 Sizeof 函数，我们可以获得一个数组变量的总大小

### 声明一个数组类型变量的同时，也可以显式地对它进行初始化。如果不进行显式初始化，那么数组中的元素值就是它类型的零值

### 数组类型变量是一个整体，这就意味着一个数组变量表示的是整个数组。无论是参与迭代，还是作为实际参数传给一个函数 / 方法，Go 传递数组的方式都是纯粹的值拷贝，这会带来较大的内存拷贝开销

### 切片包含三个字段

#### array: 是指向底层数组的指针；

#### len: 是切片的长度，即切片中当前元素的个数；

#### cap: 是底层数组的长度，也是切片的最大容量，cap 值永远大于等于 len 值。

### 创建切片

#### 通过 make 函数来创建切片，并指定底层数组的长度

#### 采用 array[low : high : max]语法基于一个已存在的数组创建切片。这种方式被称为数组的切片化

#### 基于切片创建切片

### 切片的动态扩容

## 复合数据类型：原生map类型的实现机制是怎样的？

### map 是我们既切片之后，学到的第二个由 Go 编译器与运行时联合实现的复合数据类型

### key 的类型必须支持“==”和“!=”两种比较操作符。

#### 在 Go 语言中，函数类型、map 类型自身，以及切片只支持与 nil 的比较，而不支持同类型两个变量的比较

### map 变量的声明和初始化

#### map 类型，因为它内部实现的复杂性，无法“零值可用”

#### 使用复合字面值初始化 map 类型变量。

#### 使用 make 为 map 类型变量进行显式初始化。

### map 的基本操作

#### 插入新键值对。

#### 获取键值对数量。

##### len

#### 查找和数据读取

##### 如果这个键在 map 中并不存在，我们也会得到一个值，这个值是 value 元素类型的零值。

##### “comma ok”惯用法

#### 删除数据

##### delete

#### 遍历 map 中的键值数据

##### 遍历 map 的键值对只有一种方法，那就是像对待切片那样通过 for range 语句对 map 数据进行遍历

##### 对同一 map 做多次遍历的时候，每次遍历元素的次序都不相同。

-   程序逻辑千万不要依赖遍历 map 所得到的的元素次序。
    

### map 变量的传递开销

#### 传引用

### map 的内部实现

#### 初始状态

##### 与语法层面 map 类型变量（m）一一对应的是 *runtime.hmap 的实例，即 runtime.hmap 类型的指针。编译器会把语法层面的 map 操作重写成运行时对应的函数调用，这些运行时函数都有一个共同的特点，那就是第一个参数都是 maptype 指针类型的参数

##### 真正用来存储键值对数据的是桶，也就是 bucket，每个 bucket 中存储的是 Hash 值低 bit 位数值相同的元素，默认的元素个数为 BUCKETSIZE

##### 每个 bucket 由三部分组成，从上到下分别是 tophash 区域、key 存储区域和 value 存储区域。

-   如果 key 或 value 的数据长度大于一定数值，那么运行时不会在 bucket 中直接存储数据，而是会存储 key 或 value 数据的指针。
    
-   Go 运行时采用了把 key 和 value 分开存储的方式，而不是采用一个 kv 接着一个 kv 的 kv 紧邻方式存储，这带来的其实是算法上的复杂性，但却减少了因内存对齐带来的内存浪费
    

#### map 扩容

##### count > LoadFactor * 2^B

##### overflow bucket 过多

#### map 与并发

##### 从上面的实现原理来看，充当 map 描述符角色的 hmap 实例自身是有状态的（hmap.flags），而且对状态的读写是没有并发保护的。所以说 map 实例不是并发写安全的，也不支持并发读写

#### 考虑到 map 可以自动扩容，map 中数据元素的 value 位置可能在这一过程中发生变化，所以 Go 不允许获取 map 中 value 的地址，这个约束是在编译期间就生效的

## 复合数据类型：用结构体建立对真实世界的抽象

### 如何自定义一个新类型？

#### 第一种是类型定义（Type Definition），这也是我们最常用的类型定义方法。在这种方法中，我们会使用关键字type 来定义一个新类型 T

##### 底层类型

#### 第二种自定义新类型的方式是使用类型别名（Type Alias）

### 如何定义一个结构体类型？

#### 空标识符“_”作为结构体类型定义中的字段名称

#### 定义一个空结构体。

##### 空结构体类型变量的内存占用为 0。基于空结构体类型内存零开销这样的特性，我们在日常 Go 开发中会经常使用空结构体类型元素，作为一种“事件”信息进行 Goroutine 之间的通信

#### 使用其他结构体作为自定义结构体中字段的类型

##### 我们可以无需提供字段的名字，只需要使用其类型就可以了

##### 嵌入字段

##### 匿名字段

##### Go 语言不支持这种在结构体类型定义中，递归地放入其自身类型字段的定义方式

##### 但我们却可以拥有自身类型的指针类型、以自身类型为元素类型的切片类型，以及以自身类型作为 value 类型的 map 类型的字段

### 结构体变量的声明与初始化

#### 零值初始化

#### 使用复合字面值

##### 按顺序依次给每个结构体字段进行赋值

##### Go 推荐我们用“field:value”形式的复合字面值

#### 使用特定构造函数进行初始化

### 结构体类型的内存布局

#### 结构体类型是既数组类型之后，又一个以平铺形式存放在连续内存块中的类型

#### 内存对齐

##### 为什么会出现内存对齐的要求呢？这是出于对处理器存取数据效率的考虑

#### 你在日常定义结构体时，一定要注意结构体中字段顺序，尽量合理排序，降低结构体对内存空间的占用。

#### 通过空标识符来进行主动填充